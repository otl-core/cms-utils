import { describe, expect, it } from "vitest";
import { generateId, isValidId, getConfig } from "../src/nanoid.utils";

const ALPHABET = "23456789abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";

describe("nanoid.utils", () => {
  describe("generateId", () => {
    it("returns a string of length 10", () => {
      const id = generateId();
      expect(typeof id).toBe("string");
      expect(id).toHaveLength(10);
    });

    it("uses only characters from the allowed alphabet", () => {
      for (let i = 0; i < 50; i++) {
        const id = generateId();
        const chars = id.split("");
        for (const char of chars) {
          expect(ALPHABET).toContain(char);
        }
      }
    });

    it("generates unique IDs", () => {
      const ids = new Set<string>();
      for (let i = 0; i < 100; i++) {
        ids.add(generateId());
      }
      expect(ids.size).toBe(100);
    });

    it("does not contain ambiguous characters (0, 1, l, o, I, O)", () => {
      const forbidden = ["0", "1", "l", "o", "I", "O"];
      for (let i = 0; i < 50; i++) {
        const id = generateId();
        for (const char of forbidden) {
          expect(id).not.toContain(char);
        }
      }
    });
  });

  describe("isValidId", () => {
    it("returns true for valid IDs generated by generateId", () => {
      for (let i = 0; i < 20; i++) {
        const id = generateId();
        expect(isValidId(id)).toBe(true);
      }
    });

    it("returns true for manually constructed valid IDs", () => {
      expect(isValidId("23456789ab")).toBe(true);
      expect(isValidId("abcdefghjk")).toBe(true);
      expect(isValidId("ABCDEFGHJK")).toBe(true);
    });

    it("returns false for wrong length", () => {
      expect(isValidId("")).toBe(false);
      expect(isValidId("xr7k9mjPt")).toBe(false); // 9 chars
      expect(isValidId("xr7k9mjPtnn")).toBe(false); // 12 chars
    });

    it("returns false for characters not in alphabet - 0", () => {
      expect(isValidId("234567890a")).toBe(false);
    });

    it("returns false for characters not in alphabet - 1", () => {
      expect(isValidId("234567891a")).toBe(false);
    });

    it("returns false for characters not in alphabet - lowercase l", () => {
      expect(isValidId("23456789la")).toBe(false);
    });

    it("returns false for characters not in alphabet - lowercase o", () => {
      expect(isValidId("23456789oa")).toBe(false);
    });

    it("returns false for characters not in alphabet - uppercase I", () => {
      expect(isValidId("23456789Ia")).toBe(false);
    });

    it("returns false for characters not in alphabet - uppercase O", () => {
      expect(isValidId("23456789Oa")).toBe(false);
    });

    it("returns true for all allowed characters", () => {
      const validId = ALPHABET.slice(0, 10);
      expect(isValidId(validId)).toBe(true);
    });

    it("returns false for special characters", () => {
      expect(isValidId("23456789-a")).toBe(false);
      expect(isValidId("23456789_a")).toBe(false);
      expect(isValidId("23456789 a")).toBe(false);
    });
  });

  describe("getConfig", () => {
    it("returns correct alphabet", () => {
      const config = getConfig();
      expect(config.alphabet).toBe(ALPHABET);
    });

    it("returns correct alphabetSize", () => {
      const config = getConfig();
      expect(config.alphabetSize).toBe(ALPHABET.length);
      expect(config.alphabetSize).toBe(55);
    });

    it("returns correct length", () => {
      const config = getConfig();
      expect(config.length).toBe(10);
    });

    it("returns correct entropy", () => {
      const config = getConfig();
      expect(config.entropy).toBe(Math.pow(config.alphabetSize, config.length));
    });
  });
});
